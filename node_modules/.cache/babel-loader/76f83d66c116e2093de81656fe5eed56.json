{"ast":null,"code":"import { Group } from \"./scene/group\";\nimport { Selection } from \"./scene/selection\";\nimport { Line } from \"./scene/shape/line\";\nimport { Text } from \"./scene/shape/text\";\nimport { Arc } from \"./scene/shape/arc\";\nimport { BBox } from \"./scene/bbox\";\nimport { Matrix } from \"./scene/matrix\";\nimport { createId } from \"./util/id\";\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from \"./util/angle\"; // import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\n\nvar Tags;\n\n(function (Tags) {\n  Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n  Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\n\nvar AxisTick = function () {\n  function AxisTick() {\n    /**\n     * The line width to be used by axis ticks.\n     */\n    this.width = 1;\n    /**\n     * The line length to be used by axis ticks.\n     */\n\n    this.size = 6;\n    /**\n     * The color of the axis ticks.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n     */\n\n    this.color = 'rgba(195, 195, 195, 1)';\n    /**\n     * A hint of how many ticks to use (the exact number of ticks might differ),\n     * a `TimeInterval` or a `CountableTimeInterval`.\n     * For example:\n     *\n     *     axis.tick.count = 5;\n     *     axis.tick.count = year;\n     *     axis.tick.count = month.every(6);\n     */\n\n    this.count = 10;\n  }\n\n  return AxisTick;\n}();\n\nexport { AxisTick };\n\nvar AxisLabel = function () {\n  function AxisLabel() {\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n    /**\n     * The padding between the labels and the ticks.\n     */\n\n    this.padding = 5;\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n\n    this.color = 'rgba(87, 87, 87, 1)';\n    /**\n     * Custom label rotation in degrees.\n     * Labels are rendered perpendicular to the axis line by default.\n     * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n     * The value of this config is used as the angular offset/deflection\n     * from the default rotation.\n     */\n\n    this.rotation = 0;\n    /**\n     * By default labels and ticks are positioned to the left of the axis line.\n     * `true` positions the labels to the right of the axis line.\n     * However, if the axis is rotated, its easier to think in terms\n     * of this side or the opposite side, rather than left and right.\n     * We use the term `mirror` for conciseness, although it's not\n     * true mirroring - for example, when a label is rotated, so that\n     * it is inclined at the 45 degree angle, text flowing from north-west\n     * to south-east, ending at the tick to the left of the axis line,\n     * and then we set this config to `true`, the text will still be flowing\n     * from north-west to south-east, _starting_ at the tick to the right\n     * of the axis line.\n     */\n\n    this.mirrored = false;\n    /**\n     * Labels are rendered perpendicular to the axis line by default.\n     * Setting this config to `true` makes labels render parallel to the axis line\n     * and center aligns labels' text at the ticks.\n     */\n\n    this.parallel = false;\n  }\n\n  Object.defineProperty(AxisLabel.prototype, \"format\", {\n    get: function get() {\n      return this._format;\n    },\n    set: function set(value) {\n      // See `TimeLocaleObject` docs for the list of supported format directives.\n      if (this._format !== value) {\n        this._format = value;\n\n        if (this.onFormatChange) {\n          this.onFormatChange(value);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return AxisLabel;\n}();\n\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\n\nvar Axis = function () {\n  function Axis() {\n    // debug (bbox)\n    // private bboxRect = (() => {\n    //     const rect = new Rect();\n    //     rect.fill = undefined;\n    //     rect.stroke = 'red';\n    //     rect.strokeWidth = 1;\n    //     rect.strokeOpacity = 0.2;\n    //     return rect;\n    // })();\n    this.id = createId(this);\n    this.lineNode = new Line();\n    this.group = new Group();\n    this.line = {\n      width: 1,\n      color: 'rgba(195, 195, 195, 1)'\n    };\n    this.tick = new AxisTick();\n    this.label = new AxisLabel();\n    this.translation = {\n      x: 0,\n      y: 0\n    };\n    this.rotation = 0; // axis rotation angle in degrees\n\n    this._visibleRange = [0, 1];\n    this._title = undefined;\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n     * (in degrees).\n     */\n\n    this._gridLength = 0;\n    /**\n     * The array of styles to cycle through when rendering grid lines.\n     * For example, use two {@link GridStyle} objects for alternating styles.\n     * Contains only one {@link GridStyle} object by default, meaning all grid lines\n     * have the same style.\n     */\n\n    this.gridStyle = [{\n      stroke: 'rgba(219, 219, 219, 1)',\n      lineDash: [4, 2]\n    }];\n    /**\n     * `false` - render grid as lines of {@link gridLength} that extend the ticks\n     *           on the opposite side of the axis\n     * `true` - render grid as concentric circles that go through the ticks\n     */\n\n    this._radialGrid = false;\n    this.fractionDigits = 0;\n    this.thickness = 0;\n    this.groupSelection = Selection.select(this.group).selectAll();\n    this.label.onFormatChange = this.onLabelFormatChange.bind(this);\n    this.group.append(this.lineNode); // this.group.append(this.bboxRect); // debug (bbox)\n  }\n\n  Object.defineProperty(Axis.prototype, \"scale\", {\n    get: function get() {\n      return this._scale;\n    },\n    set: function set(value) {\n      this._scale = value;\n      this.requestedRange = value.range.slice();\n      this.onLabelFormatChange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Meant to be overridden in subclasses to provide extra context the the label formatter.\n   * The return value of this function will be passed to the laber.formatter as the `axis` parameter.\n   */\n\n  Axis.prototype.getMeta = function () {};\n\n  Axis.prototype.updateRange = function () {\n    var _a = this,\n        rr = _a.requestedRange,\n        vr = _a.visibleRange,\n        scale = _a.scale;\n\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    scale.range = [start, start + span];\n  };\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param width Object's width.\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n\n\n  Axis.prototype.inRange = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n\n    return this.inRangeEx(x, width, tolerance) === 0;\n  };\n\n  Axis.prototype.inRangeEx = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n\n    var range = this.range; // Account for inverted ranges, for example [500, 100] as well as [100, 500]\n\n    var min = Math.min(range[0], range[1]);\n    var max = Math.max(range[0], range[1]);\n\n    if (x + width < min - tolerance) {\n      return -1; // left of range\n    }\n\n    if (x > max + tolerance) {\n      return 1; // right of range\n    }\n\n    return 0; // in range\n  };\n\n  Object.defineProperty(Axis.prototype, \"range\", {\n    get: function get() {\n      return this.requestedRange.slice();\n    },\n    set: function set(value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"visibleRange\", {\n    get: function get() {\n      return this._visibleRange.slice();\n    },\n    set: function set(value) {\n      if (value && value.length === 2) {\n        var min = value[0],\n            max = value[1];\n        min = Math.max(0, min);\n        max = Math.min(1, max);\n        min = Math.min(min, max);\n        max = Math.max(min, max);\n        this._visibleRange = [min, max];\n        this.updateRange();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"domain\", {\n    get: function get() {\n      return this.scale.domain.slice();\n    },\n    set: function set(value) {\n      this.scale.domain = value.slice();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Axis.prototype.onLabelFormatChange = function (format) {\n    if (format) {\n      if (this.scale && this.scale.tickFormat) {\n        this.labelFormatter = this.scale.tickFormat(this.tick.count, format);\n      }\n    } else {\n      this.labelFormatter = undefined;\n    }\n  };\n\n  Object.defineProperty(Axis.prototype, \"title\", {\n    get: function get() {\n      return this._title;\n    },\n    set: function set(value) {\n      var oldTitle = this._title;\n\n      if (oldTitle !== value) {\n        if (oldTitle) {\n          this.group.removeChild(oldTitle.node);\n        }\n\n        if (value) {\n          value.node.rotation = -Math.PI / 2;\n          this.group.appendChild(value.node);\n        }\n\n        this._title = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"gridLength\", {\n    get: function get() {\n      return this._gridLength;\n    },\n    set: function set(value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"radialGrid\", {\n    get: function get() {\n      return this._radialGrid;\n    },\n    set: function set(value) {\n      if (this._radialGrid !== value) {\n        this._radialGrid = value;\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n\n  Axis.prototype.update = function () {\n    var _this = this;\n\n    var _a = this,\n        group = _a.group,\n        scale = _a.scale,\n        tick = _a.tick,\n        label = _a.label,\n        gridStyle = _a.gridStyle,\n        requestedRange = _a.requestedRange;\n\n    var requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n    var requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n    var rotation = toRadians(this.rotation);\n    var parallelLabels = label.parallel;\n    var labelRotation = normalizeAngle360(toRadians(label.rotation));\n    group.translationX = this.translation.x;\n    group.translationY = this.translation.y;\n    group.rotation = rotation;\n    var halfBandwidth = (scale.bandwidth || 0) / 2; // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n\n    var sideFlag = label.mirrored ? 1 : -1; // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2); // Flip if the axis rotation angle is in the top hemisphere.\n\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n    var ticks = scale.ticks(this.tick.count);\n    var update = this.groupSelection.setData(ticks);\n    update.exit.remove();\n    var enter = update.enter.append(Group); // Line auto-snaps to pixel grid if vertical or horizontal.\n\n    enter.append(Line).each(function (node) {\n      return node.tag = Tags.Tick;\n    });\n\n    if (this.gridLength) {\n      if (this.radialGrid) {\n        enter.append(Arc).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      } else {\n        enter.append(Line).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      }\n    }\n\n    enter.append(Text);\n    var groupSelection = update.merge(enter);\n    groupSelection.attrFn('translationY', function (_, datum) {\n      return Math.round(scale.convert(datum) + halfBandwidth);\n    }).attrFn('visible', function (node) {\n      return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n    });\n    groupSelection.selectByTag(Tags.Tick).each(function (line) {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.color;\n    }).attr('x1', sideFlag * tick.size).attr('x2', 0).attr('y1', 0).attr('y2', 0);\n\n    if (this.gridLength && gridStyle.length) {\n      var styleCount_1 = gridStyle.length;\n      var gridLines = void 0;\n\n      if (this.radialGrid) {\n        var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(this.gridLength));\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (arc, datum) {\n          var radius = Math.round(scale.convert(datum) + halfBandwidth);\n          arc.centerX = 0;\n          arc.centerY = scale.range[0] - radius;\n          arc.endAngle = angularGridLength_1;\n          arc.radiusX = radius;\n          arc.radiusY = radius;\n        });\n      } else {\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (line) {\n          line.x1 = 0;\n          line.x2 = -sideFlag * _this.gridLength;\n          line.y1 = 0;\n          line.y2 = 0;\n          line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n        });\n      }\n\n      gridLines.each(function (gridLine, _, index) {\n        var style = gridStyle[index % styleCount_1];\n        gridLine.stroke = style.stroke;\n        gridLine.strokeWidth = tick.width;\n        gridLine.lineDash = style.lineDash;\n        gridLine.fill = undefined;\n      });\n    } // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n\n\n    this.fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n    var labelSelection = groupSelection.selectByClass(Text).each(function (node, datum, index) {\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.textBaseline = parallelLabels && !labelRotation ? sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom' : 'middle';\n      node.text = _this.formatTickDatum(datum, index);\n      node.textAlign = parallelLabels ? labelRotation ? sideFlag * alignFlag === -1 ? 'end' : 'start' : 'center' : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n    });\n    var labelX = sideFlag * (tick.size + label.padding);\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    labelSelection.each(function (label) {\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n      label.rotation = autoRotation + labelRotation;\n    });\n    this.groupSelection = groupSelection; // Render axis line.\n\n    var lineNode = this.lineNode;\n    lineNode.x1 = 0;\n    lineNode.x2 = 0;\n    lineNode.y1 = requestedRange[0];\n    lineNode.y2 = requestedRange[1];\n    lineNode.strokeWidth = this.line.width;\n    lineNode.stroke = this.line.color;\n    lineNode.visible = ticks.length > 0;\n    var title = this.title;\n    var titleVisible = false;\n\n    if (title && title.enabled) {\n      titleVisible = true;\n      var padding = title.padding.bottom;\n      var titleNode = title.node;\n      var bbox = this.computeBBox({\n        excludeTitle: true\n      });\n      var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n      titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n      titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n      titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n\n      if (sideFlag === -1) {\n        titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n      } else {\n        titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n      }\n\n      titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n    }\n\n    if (title) {\n      title.node.visible = titleVisible;\n    } // debug (bbox)\n    // const bbox = this.computeBBox();\n    // const bboxRect = this.bboxRect;\n    // bboxRect.x = bbox.x;\n    // bboxRect.y = bbox.y;\n    // bboxRect.width = bbox.width;\n    // bboxRect.height = bbox.height;\n\n  }; // For formatting (nice rounded) tick values.\n\n\n  Axis.prototype.formatTickDatum = function (datum, index) {\n    var _a = this,\n        label = _a.label,\n        labelFormatter = _a.labelFormatter,\n        fractionDigits = _a.fractionDigits;\n\n    var meta = this.getMeta();\n    return label.formatter ? label.formatter({\n      value: fractionDigits >= 0 ? datum : String(datum),\n      index: index,\n      fractionDigits: fractionDigits,\n      formatter: labelFormatter,\n      axis: meta\n    }) : labelFormatter ? labelFormatter(datum) : typeof datum === 'number' && fractionDigits >= 0 // the `datum` is a floating point number\n    ? datum.toFixed(fractionDigits) // the`datum` is an integer, a string or an object\n    : String(datum);\n  }; // For formatting arbitrary values between the ticks.\n\n\n  Axis.prototype.formatDatum = function (datum) {\n    return String(datum);\n  };\n\n  Axis.prototype.computeBBox = function (options) {\n    var _a = this,\n        title = _a.title,\n        lineNode = _a.lineNode;\n\n    var labels = this.groupSelection.selectByClass(Text);\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n    labels.each(function (label) {\n      // The label itself is rotated, but not translated, the group that\n      // contains it is. So to capture the group transform in the label bbox\n      // calculation we combine the transform matrices of the label and the group.\n      // Depending on the timing of the `axis.computeBBox()` method call, we may\n      // not have the group's and the label's transform matrices updated yet (because\n      // the transform matrix is not recalculated whenever a node's transform attributes\n      // change, instead it's marked for recalculation on the next frame by setting\n      // the node's `dirtyTransform` flag to `true`), so we force them to update\n      // right here by calling `computeTransformMatrix`.\n      label.computeTransformMatrix();\n      var matrix = Matrix.flyweight(label.matrix);\n      var group = label.parent;\n      group.computeTransformMatrix();\n      matrix.preMultiplySelf(group.matrix);\n      var labelBBox = label.computeBBox();\n\n      if (labelBBox) {\n        var bbox = matrix.transformBBox(labelBBox);\n        left = Math.min(left, bbox.x);\n        right = Math.max(right, bbox.x + bbox.width);\n        top = Math.min(top, bbox.y);\n        bottom = Math.max(bottom, bbox.y + bbox.height);\n      }\n    });\n\n    if (title && title.enabled && (!options || !options.excludeTitle)) {\n      var label = title.node;\n      label.computeTransformMatrix();\n      var matrix = Matrix.flyweight(label.matrix);\n      var labelBBox = label.computeBBox();\n\n      if (labelBBox) {\n        var bbox = matrix.transformBBox(labelBBox);\n        left = Math.min(left, bbox.x);\n        right = Math.max(right, bbox.x + bbox.width);\n        top = Math.min(top, bbox.y);\n        bottom = Math.max(bottom, bbox.y + bbox.height);\n      }\n    }\n\n    left = Math.min(left, 0);\n    right = Math.max(right, 0);\n    top = Math.min(top, lineNode.y1, lineNode.y2);\n    bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n    return new BBox(left, top, right - left, bottom - top);\n  };\n\n  return Axis;\n}();\n\nexport { Axis };","map":{"version":3,"sources":["/Users/julianneagresta/Projects/openlibrary-search-histogram/node_modules/ag-charts-community/dist/es6/axis.js"],"names":["Group","Selection","Line","Text","Arc","BBox","Matrix","createId","normalizeAngle360","normalizeAngle360Inclusive","toRadians","Tags","AxisTick","width","size","color","count","AxisLabel","fontSize","fontFamily","padding","rotation","mirrored","parallel","Object","defineProperty","prototype","get","_format","set","value","onFormatChange","enumerable","configurable","Axis","id","lineNode","group","line","tick","label","translation","x","y","_visibleRange","_title","undefined","_gridLength","gridStyle","stroke","lineDash","_radialGrid","fractionDigits","thickness","groupSelection","select","selectAll","onLabelFormatChange","bind","append","_scale","requestedRange","range","slice","getMeta","updateRange","_a","rr","vr","visibleRange","scale","span","shift","start","inRange","tolerance","inRangeEx","min","Math","max","length","domain","format","tickFormat","labelFormatter","oldTitle","removeChild","node","PI","appendChild","remove","setData","update","_this","requestedRangeMin","requestedRangeMax","parallelLabels","labelRotation","translationX","translationY","halfBandwidth","bandwidth","sideFlag","parallelFlipRotation","parallelFlipFlag","regularFlipRotation","regularFlipFlag","alignFlag","ticks","exit","enter","each","tag","Tick","gridLength","radialGrid","GridLine","merge","attrFn","_","datum","round","convert","selectByTag","strokeWidth","attr","styleCount_1","gridLines","angularGridLength_1","arc","radius","centerX","centerY","endAngle","radiusX","radiusY","x1","x2","y1","y2","visible","abs","parent","gridLine","index","style","fill","labelSelection","selectByClass","fontStyle","fontWeight","textBaseline","text","formatTickDatum","textAlign","labelX","autoRotation","rotationCenterX","title","titleVisible","enabled","bottom","titleNode","bbox","computeBBox","excludeTitle","titleRotationFlag","meta","formatter","String","axis","toFixed","formatDatum","options","labels","left","Infinity","right","top","computeTransformMatrix","matrix","flyweight","preMultiplySelf","labelBBox","transformBBox","height"],"mappings":"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","sourcesContent":["import { Group } from \"./scene/group\";\nimport { Selection } from \"./scene/selection\";\nimport { Line } from \"./scene/shape/line\";\nimport { Text } from \"./scene/shape/text\";\nimport { Arc } from \"./scene/shape/arc\";\nimport { BBox } from \"./scene/bbox\";\nimport { Matrix } from \"./scene/matrix\";\nimport { createId } from \"./util/id\";\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from \"./util/angle\";\n// import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\nvar Tags;\n(function (Tags) {\n    Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n    Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\nvar AxisTick = /** @class */ (function () {\n    function AxisTick() {\n        /**\n         * The line width to be used by axis ticks.\n         */\n        this.width = 1;\n        /**\n         * The line length to be used by axis ticks.\n         */\n        this.size = 6;\n        /**\n         * The color of the axis ticks.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n         */\n        this.color = 'rgba(195, 195, 195, 1)';\n        /**\n         * A hint of how many ticks to use (the exact number of ticks might differ),\n         * a `TimeInterval` or a `CountableTimeInterval`.\n         * For example:\n         *\n         *     axis.tick.count = 5;\n         *     axis.tick.count = year;\n         *     axis.tick.count = month.every(6);\n         */\n        this.count = 10;\n    }\n    return AxisTick;\n}());\nexport { AxisTick };\nvar AxisLabel = /** @class */ (function () {\n    function AxisLabel() {\n        this.fontSize = 12;\n        this.fontFamily = 'Verdana, sans-serif';\n        /**\n         * The padding between the labels and the ticks.\n         */\n        this.padding = 5;\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        this.color = 'rgba(87, 87, 87, 1)';\n        /**\n         * Custom label rotation in degrees.\n         * Labels are rendered perpendicular to the axis line by default.\n         * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n         * The value of this config is used as the angular offset/deflection\n         * from the default rotation.\n         */\n        this.rotation = 0;\n        /**\n         * By default labels and ticks are positioned to the left of the axis line.\n         * `true` positions the labels to the right of the axis line.\n         * However, if the axis is rotated, its easier to think in terms\n         * of this side or the opposite side, rather than left and right.\n         * We use the term `mirror` for conciseness, although it's not\n         * true mirroring - for example, when a label is rotated, so that\n         * it is inclined at the 45 degree angle, text flowing from north-west\n         * to south-east, ending at the tick to the left of the axis line,\n         * and then we set this config to `true`, the text will still be flowing\n         * from north-west to south-east, _starting_ at the tick to the right\n         * of the axis line.\n         */\n        this.mirrored = false;\n        /**\n         * Labels are rendered perpendicular to the axis line by default.\n         * Setting this config to `true` makes labels render parallel to the axis line\n         * and center aligns labels' text at the ticks.\n         */\n        this.parallel = false;\n    }\n    Object.defineProperty(AxisLabel.prototype, \"format\", {\n        get: function () {\n            return this._format;\n        },\n        set: function (value) {\n            // See `TimeLocaleObject` docs for the list of supported format directives.\n            if (this._format !== value) {\n                this._format = value;\n                if (this.onFormatChange) {\n                    this.onFormatChange(value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AxisLabel;\n}());\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar Axis = /** @class */ (function () {\n    function Axis() {\n        // debug (bbox)\n        // private bboxRect = (() => {\n        //     const rect = new Rect();\n        //     rect.fill = undefined;\n        //     rect.stroke = 'red';\n        //     rect.strokeWidth = 1;\n        //     rect.strokeOpacity = 0.2;\n        //     return rect;\n        // })();\n        this.id = createId(this);\n        this.lineNode = new Line();\n        this.group = new Group();\n        this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        this.tick = new AxisTick();\n        this.label = new AxisLabel();\n        this.translation = { x: 0, y: 0 };\n        this.rotation = 0; // axis rotation angle in degrees\n        this._visibleRange = [0, 1];\n        this._title = undefined;\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n         * (in degrees).\n         */\n        this._gridLength = 0;\n        /**\n         * The array of styles to cycle through when rendering grid lines.\n         * For example, use two {@link GridStyle} objects for alternating styles.\n         * Contains only one {@link GridStyle} object by default, meaning all grid lines\n         * have the same style.\n         */\n        this.gridStyle = [{\n                stroke: 'rgba(219, 219, 219, 1)',\n                lineDash: [4, 2]\n            }];\n        /**\n         * `false` - render grid as lines of {@link gridLength} that extend the ticks\n         *           on the opposite side of the axis\n         * `true` - render grid as concentric circles that go through the ticks\n         */\n        this._radialGrid = false;\n        this.fractionDigits = 0;\n        this.thickness = 0;\n        this.groupSelection = Selection.select(this.group).selectAll();\n        this.label.onFormatChange = this.onLabelFormatChange.bind(this);\n        this.group.append(this.lineNode);\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Object.defineProperty(Axis.prototype, \"scale\", {\n        get: function () {\n            return this._scale;\n        },\n        set: function (value) {\n            this._scale = value;\n            this.requestedRange = value.range.slice();\n            this.onLabelFormatChange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Meant to be overridden in subclasses to provide extra context the the label formatter.\n     * The return value of this function will be passed to the laber.formatter as the `axis` parameter.\n     */\n    Axis.prototype.getMeta = function () { };\n    Axis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        scale.range = [start, start + span];\n    };\n    /**\n     * Checks if a point or an object is in range.\n     * @param x A point (or object's starting point).\n     * @param width Object's width.\n     * @param tolerance Expands the range on both ends by this amount.\n     */\n    Axis.prototype.inRange = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        return this.inRangeEx(x, width, tolerance) === 0;\n    };\n    Axis.prototype.inRangeEx = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        var range = this.range;\n        // Account for inverted ranges, for example [500, 100] as well as [100, 500]\n        var min = Math.min(range[0], range[1]);\n        var max = Math.max(range[0], range[1]);\n        if ((x + width) < (min - tolerance)) {\n            return -1; // left of range\n        }\n        if (x > (max + tolerance)) {\n            return 1; // right of range\n        }\n        return 0; // in range\n    };\n    Object.defineProperty(Axis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"visibleRange\", {\n        get: function () {\n            return this._visibleRange.slice();\n        },\n        set: function (value) {\n            if (value && value.length === 2) {\n                var min = value[0], max = value[1];\n                min = Math.max(0, min);\n                max = Math.min(1, max);\n                min = Math.min(min, max);\n                max = Math.max(min, max);\n                this._visibleRange = [min, max];\n                this.updateRange();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain.slice();\n        },\n        set: function (value) {\n            this.scale.domain = value.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Axis.prototype.onLabelFormatChange = function (format) {\n        if (format) {\n            if (this.scale && this.scale.tickFormat) {\n                this.labelFormatter = this.scale.tickFormat(this.tick.count, format);\n            }\n        }\n        else {\n            this.labelFormatter = undefined;\n        }\n    };\n    Object.defineProperty(Axis.prototype, \"title\", {\n        get: function () {\n            return this._title;\n        },\n        set: function (value) {\n            var oldTitle = this._title;\n            if (oldTitle !== value) {\n                if (oldTitle) {\n                    this.group.removeChild(oldTitle.node);\n                }\n                if (value) {\n                    value.node.rotation = -Math.PI / 2;\n                    this.group.appendChild(value.node);\n                }\n                this._title = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"radialGrid\", {\n        get: function () {\n            return this._radialGrid;\n        },\n        set: function (value) {\n            if (this._radialGrid !== value) {\n                this._radialGrid = value;\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    Axis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, tick = _a.tick, label = _a.label, gridStyle = _a.gridStyle, requestedRange = _a.requestedRange;\n        var requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n        var requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n        var rotation = toRadians(this.rotation);\n        var parallelLabels = label.parallel;\n        var labelRotation = normalizeAngle360(toRadians(label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var halfBandwidth = (scale.bandwidth || 0) / 2;\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, π] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n        var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n        var ticks = scale.ticks(this.tick.count);\n        var update = this.groupSelection.setData(ticks);\n        update.exit.remove();\n        var enter = update.enter.append(Group);\n        // Line auto-snaps to pixel grid if vertical or horizontal.\n        enter.append(Line).each(function (node) { return node.tag = Tags.Tick; });\n        if (this.gridLength) {\n            if (this.radialGrid) {\n                enter.append(Arc).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n            else {\n                enter.append(Line).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n        }\n        enter.append(Text);\n        var groupSelection = update.merge(enter);\n        groupSelection\n            .attrFn('translationY', function (_, datum) {\n            return Math.round(scale.convert(datum) + halfBandwidth);\n        })\n            .attrFn('visible', function (node) {\n            return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n        });\n        groupSelection.selectByTag(Tags.Tick)\n            .each(function (line) {\n            line.strokeWidth = tick.width;\n            line.stroke = tick.color;\n        })\n            .attr('x1', sideFlag * tick.size)\n            .attr('x2', 0)\n            .attr('y1', 0)\n            .attr('y2', 0);\n        if (this.gridLength && gridStyle.length) {\n            var styleCount_1 = gridStyle.length;\n            var gridLines = void 0;\n            if (this.radialGrid) {\n                var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(this.gridLength));\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (arc, datum) {\n                    var radius = Math.round(scale.convert(datum) + halfBandwidth);\n                    arc.centerX = 0;\n                    arc.centerY = scale.range[0] - radius;\n                    arc.endAngle = angularGridLength_1;\n                    arc.radiusX = radius;\n                    arc.radiusY = radius;\n                });\n            }\n            else {\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (line) {\n                    line.x1 = 0;\n                    line.x2 = -sideFlag * _this.gridLength;\n                    line.y1 = 0;\n                    line.y2 = 0;\n                    line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n                });\n            }\n            gridLines.each(function (gridLine, _, index) {\n                var style = gridStyle[index % styleCount_1];\n                gridLine.stroke = style.stroke;\n                gridLine.strokeWidth = tick.width;\n                gridLine.lineDash = style.lineDash;\n                gridLine.fill = undefined;\n            });\n        }\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n        this.fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n        var labelSelection = groupSelection.selectByClass(Text)\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelLabels && !labelRotation\n                ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n                : 'middle';\n            node.text = _this.formatTickDatum(datum, index);\n            node.textAlign = parallelLabels\n                ? labelRotation ? (sideFlag * alignFlag === -1 ? 'end' : 'start') : 'center'\n                : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n        });\n        var labelX = sideFlag * (tick.size + label.padding);\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        labelSelection.each(function (label) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            label.rotation = autoRotation + labelRotation;\n        });\n        this.groupSelection = groupSelection;\n        // Render axis line.\n        var lineNode = this.lineNode;\n        lineNode.x1 = 0;\n        lineNode.x2 = 0;\n        lineNode.y1 = requestedRange[0];\n        lineNode.y2 = requestedRange[1];\n        lineNode.strokeWidth = this.line.width;\n        lineNode.stroke = this.line.color;\n        lineNode.visible = ticks.length > 0;\n        var title = this.title;\n        var titleVisible = false;\n        if (title && title.enabled) {\n            titleVisible = true;\n            var padding = title.padding.bottom;\n            var titleNode = title.node;\n            var bbox = this.computeBBox({ excludeTitle: true });\n            var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n            titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n            if (sideFlag === -1) {\n                titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n            }\n            else {\n                titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n            }\n            titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n        }\n        if (title) {\n            title.node.visible = titleVisible;\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    // For formatting (nice rounded) tick values.\n    Axis.prototype.formatTickDatum = function (datum, index) {\n        var _a = this, label = _a.label, labelFormatter = _a.labelFormatter, fractionDigits = _a.fractionDigits;\n        var meta = this.getMeta();\n        return label.formatter\n            ? label.formatter({\n                value: fractionDigits >= 0 ? datum : String(datum),\n                index: index,\n                fractionDigits: fractionDigits,\n                formatter: labelFormatter,\n                axis: meta\n            })\n            : labelFormatter\n                ? labelFormatter(datum)\n                : typeof datum === 'number' && fractionDigits >= 0\n                    // the `datum` is a floating point number\n                    ? datum.toFixed(fractionDigits)\n                    // the`datum` is an integer, a string or an object\n                    : String(datum);\n    };\n    // For formatting arbitrary values between the ticks.\n    Axis.prototype.formatDatum = function (datum) {\n        return String(datum);\n    };\n    Axis.prototype.computeBBox = function (options) {\n        var _a = this, title = _a.title, lineNode = _a.lineNode;\n        var labels = this.groupSelection.selectByClass(Text);\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        labels.each(function (label) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var group = label.parent;\n            group.computeTransformMatrix();\n            matrix.preMultiplySelf(group.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        });\n        if (title && title.enabled && (!options || !options.excludeTitle)) {\n            var label = title.node;\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        }\n        left = Math.min(left, 0);\n        right = Math.max(right, 0);\n        top = Math.min(top, lineNode.y1, lineNode.y2);\n        bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n        return new BBox(left, top, right - left, bottom - top);\n    };\n    return Axis;\n}());\nexport { Axis };\n"]},"metadata":{},"sourceType":"module"}