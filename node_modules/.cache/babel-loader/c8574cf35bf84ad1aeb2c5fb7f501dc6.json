{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Selection } from \"../../scene/selection\";\nimport { Line } from \"../../scene/shape/line\";\nimport { normalizeAngle360, toRadians } from \"../../util/angle\";\nimport { Text } from \"../../scene/shape/text\";\nimport { BBox } from \"../../scene/bbox\";\nimport { Matrix } from \"../../scene/matrix\"; // import { Rect } from \"../../scene/shape/rect\"; debug (bbox)\n\nimport { BandScale } from \"../../scale/bandScale\";\nimport { ticksToTree, treeLayout } from \"../../layout/tree\";\nimport { AxisLabel } from \"../../axis\";\nimport { ChartAxis } from \"../chartAxis\";\n\nvar GroupedCategoryAxisLabel = function (_super) {\n  __extends(GroupedCategoryAxisLabel, _super);\n\n  function GroupedCategoryAxisLabel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.grid = false;\n    return _this;\n  }\n\n  return GroupedCategoryAxisLabel;\n}(AxisLabel);\n\nvar GroupedCategoryAxis = function (_super) {\n  __extends(GroupedCategoryAxis, _super);\n\n  function GroupedCategoryAxis() {\n    var _this = _super.call(this) || this; // Label scale (labels are positionsed between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n\n\n    _this.tickScale = new BandScale();\n    _this.longestSeparatorLength = 0;\n    _this.translation = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Axis rotation angle in degrees.\n     */\n\n    _this.rotation = 0;\n    _this.line = {\n      width: 1,\n      color: 'rgba(195, 195, 195, 1)'\n    }; // readonly tick = new AxisTick();\n\n    _this.label = new GroupedCategoryAxisLabel();\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n\n    _this.labelColor = 'rgba(87, 87, 87, 1)';\n    var _a = _this,\n        group = _a.group,\n        tickScale = _a.tickScale;\n    var scale = new BandScale();\n    scale.paddingOuter = 0.1;\n    scale.paddingInner = scale.paddingOuter * 2;\n    _this.requestedRange = scale.range.slice();\n    _this.scale = scale;\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    _this.gridLineSelection = Selection.select(group).selectAll();\n    _this.axisLineSelection = Selection.select(group).selectAll();\n    _this.separatorSelection = Selection.select(group).selectAll();\n    _this.labelSelection = Selection.select(group).selectAll();\n    return _this; // this.group.append(this.bboxRect); // debug (bbox)\n  }\n\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"domain\", {\n    get: function get() {\n      return this.scale.domain;\n    },\n    set: function set(values) {\n      this.scale.domain = values;\n      var tickTree = ticksToTree(values);\n      this.tickTreeLayout = treeLayout(tickTree);\n      var domain = values.slice();\n      domain.push('');\n      this.tickScale.domain = domain;\n      this.resizeTickTree();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n    get: function get() {\n      return this.requestedRange.slice();\n    },\n    set: function set(value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  GroupedCategoryAxis.prototype.updateRange = function () {\n    var _a = this,\n        rr = _a.requestedRange,\n        vr = _a.visibleRange,\n        scale = _a.scale;\n\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    this.tickScale.range = scale.range = [start, start + span];\n    this.resizeTickTree();\n  };\n\n  GroupedCategoryAxis.prototype.resizeTickTree = function () {\n    var s = this.scale;\n    var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    var layout = this.tickTreeLayout;\n    var lineHeight = this.lineHeight;\n\n    if (layout) {\n      layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\n    }\n  };\n\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n    get: function get() {\n      return this.label.fontSize * 1.5;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n    get: function get() {\n      return this._gridLength;\n    },\n\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     */\n    set: function set(value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n        this.labelSelection = this.labelSelection.remove().setData([]);\n      }\n\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n\n  GroupedCategoryAxis.prototype.update = function () {\n    var _this = this;\n\n    var _a = this,\n        group = _a.group,\n        scale = _a.scale,\n        label = _a.label,\n        tickScale = _a.tickScale,\n        requestedRange = _a.requestedRange;\n\n    var rangeStart = scale.range[0];\n    var rangeEnd = scale.range[1];\n    var rangeLength = Math.abs(rangeEnd - rangeStart);\n    var bandwidth = rangeLength / scale.domain.length || 0;\n    var parallelLabels = label.parallel;\n    var rotation = toRadians(this.rotation);\n    var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    var labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n    group.translationX = this.translation.x;\n    group.translationY = this.translation.y;\n    group.rotation = rotation;\n    var title = this.title; // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n    // The phantom root of the tree layout is used instead.\n\n    if (title) {\n      title.node.visible = false;\n    }\n\n    var lineHeight = this.lineHeight; // Render ticks and labels.\n\n    var tickTreeLayout = this.tickTreeLayout;\n    var labels = scale.ticks();\n    var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    var ticks = tickScale.ticks(); // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n\n    var sideFlag = label.mirrored ? 1 : -1; // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2); // Flip if the axis rotation angle is in the top hemisphere.\n\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n    updateGridLines.exit.remove();\n    var enterGridLines = updateGridLines.enter.append(Line);\n    var gridLineSelection = updateGridLines.merge(enterGridLines);\n    var updateLabels = this.labelSelection.setData(treeLabels);\n    updateLabels.exit.remove();\n    var enterLabels = updateLabels.enter.append(Text);\n    var labelSelection = updateLabels.merge(enterLabels);\n    var labelFormatter = label.formatter;\n    var maxLeafLabelWidth = 0;\n    labelSelection.each(function (node, datum, index) {\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging'; // label.textBaseline = parallelLabels && !labelRotation\n      //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n      //     : 'middle';\n\n      node.textAlign = 'center';\n      node.translationX = datum.screenY - label.fontSize * 0.25;\n      node.translationY = datum.screenX;\n\n      if (index === 0) {\n        // use the phantom root as the axis title\n        if (title && title.enabled && labels.length > 0) {\n          node.visible = true;\n          node.text = title.text;\n          node.fontSize = title.fontSize;\n          node.fontStyle = title.fontStyle;\n          node.fontWeight = title.fontWeight;\n          node.fontFamily = title.fontFamily;\n          node.textBaseline = 'hanging';\n        } else {\n          node.visible = false;\n        }\n      } else {\n        node.text = labelFormatter ? labelFormatter({\n          value: String(datum.label),\n          index: index\n        }) : String(datum.label);\n        node.visible = datum.screenX >= requestedRange[0] && datum.screenX <= requestedRange[1];\n      }\n\n      var bbox = node.computeBBox();\n\n      if (bbox && bbox.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox.width;\n      }\n    });\n    var labelX = sideFlag * label.padding;\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    var labelGrid = this.label.grid;\n    var separatorData = [];\n    labelSelection.each(function (label, datum, index) {\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n\n      if (!datum.children.length) {\n        label.rotation = labelRotation;\n        label.textAlign = 'end';\n        label.textBaseline = 'middle';\n      } else {\n        label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n\n        if (isHorizontal) {\n          label.rotation = autoRotation;\n        } else {\n          label.rotation = -Math.PI / 2;\n        }\n      } // Calculate positions of label separators for all nodes except the root.\n      // Each separator is placed to the top of the current label.\n\n\n      if (datum.parent && isLabelTree) {\n        var y = !datum.children.length ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n\n        if (!datum.children.length) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y: y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - _this.label.padding * 2,\n              toString: function toString() {\n                return String(index);\n              }\n            });\n          }\n        } else {\n          var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y: y,\n            x1: x + lineHeight,\n            x2: x,\n            toString: function toString() {\n              return String(index);\n            }\n          });\n        }\n      }\n    }); // Calculate the position of the long separator on the far bottom of the axis.\n\n    var minX = 0;\n    separatorData.forEach(function (d) {\n      return minX = Math.min(minX, d.x2);\n    });\n    this.longestSeparatorLength = Math.abs(minX);\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX,\n      toString: function toString() {\n        return String(separatorData.length);\n      }\n    });\n    var updateSeparators = this.separatorSelection.setData(separatorData);\n    updateSeparators.exit.remove();\n    var enterSeparators = updateSeparators.enter.append(Line);\n    var separatorSelection = updateSeparators.merge(enterSeparators);\n    this.separatorSelection = separatorSelection;\n    var epsilon = 0.0000001;\n    separatorSelection.each(function (line, datum, i) {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n      line.stroke = _this.tick.color;\n      line.fill = undefined;\n      line.strokeWidth = 1;\n    });\n    this.gridLineSelection = gridLineSelection;\n    this.labelSelection = labelSelection; // Render axis lines.\n\n    var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    var lines = [];\n\n    for (var i = 0; i < lineCount; i++) {\n      lines.push(i);\n    }\n\n    var updateAxisLines = this.axisLineSelection.setData(lines);\n    updateAxisLines.exit.remove();\n    var enterAxisLines = updateAxisLines.enter.append(Line);\n    var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n    this.axisLineSelection = axisLineSelection;\n    axisLineSelection.each(function (line, _, index) {\n      var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n      line.x1 = x;\n      line.x2 = x;\n      line.y1 = requestedRange[0];\n      line.y2 = requestedRange[1];\n      line.strokeWidth = _this.line.width;\n      line.stroke = _this.line.color;\n      line.visible = labels.length > 0 && (index === 0 || labelGrid && isLabelTree);\n    });\n\n    if (this.gridLength) {\n      var styles_1 = this.gridStyle;\n      var styleCount_1 = styles_1.length;\n      gridLineSelection.each(function (line, datum, index) {\n        var y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * _this.gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = y >= requestedRange[0] && y <= requestedRange[1] && Math.abs(line.parent.translationY - rangeStart) > 1;\n        var style = styles_1[index % styleCount_1];\n        line.stroke = style.stroke;\n        line.strokeWidth = _this.tick.width;\n        line.lineDash = style.lineDash;\n        line.fill = undefined;\n      });\n    } // debug (bbox)\n    // const bbox = this.computeBBox();\n    // const bboxRect = this.bboxRect;\n    // bboxRect.x = bbox.x;\n    // bboxRect.y = bbox.y;\n    // bboxRect.width = bbox.width;\n    // bboxRect.height = bbox.height;\n\n  };\n\n  GroupedCategoryAxis.prototype.computeBBox = function (options) {\n    var includeTitle = !options || !options.excludeTitle;\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n    this.labelSelection.each(function (label, _, index) {\n      // The label itself is rotated, but not translated, the group that\n      // contains it is. So to capture the group transform in the label bbox\n      // calculation we combine the transform matrices of the label and the group.\n      // Depending on the timing of the `axis.computeBBox()` method call, we may\n      // not have the group's and the label's transform matrices updated yet (because\n      // the transform matrix is not recalculated whenever a node's transform attributes\n      // change, instead it's marked for recalculation on the next frame by setting\n      // the node's `dirtyTransform` flag to `true`), so we force them to update\n      // right here by calling `computeTransformMatrix`.\n      if (index > 0 || includeTitle) {\n        // first node is the root (title)\n        label.computeTransformMatrix();\n        var matrix = Matrix.flyweight(label.matrix);\n        var labelBBox = label.computeBBox();\n\n        if (labelBBox) {\n          var bbox = matrix.transformBBox(labelBBox);\n          left = Math.min(left, bbox.x);\n          right = Math.max(right, bbox.x + bbox.width);\n          top = Math.min(top, bbox.y);\n          bottom = Math.max(bottom, bbox.y + bbox.height);\n        }\n      }\n    });\n    return new BBox(left, top, Math.max(right - left, this.longestSeparatorLength), bottom - top);\n  }; // debug (bbox)\n  // private bboxRect = (() => {\n  //     const rect = new Rect();\n  //     rect.fill = undefined;\n  //     rect.stroke = 'red';\n  //     rect.strokeWidth = 1;\n  //     rect.strokeOpacity = 0.2;\n  //     return rect;\n  // })();\n\n\n  GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n  GroupedCategoryAxis.type = 'groupedCategory';\n  return GroupedCategoryAxis;\n}(ChartAxis);\n\nexport { GroupedCategoryAxis };","map":{"version":3,"sources":["/Users/julianneagresta/Projects/openlibrary-search-histogram/node_modules/ag-charts-community/dist/es6/chart/axis/groupedCategoryAxis.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Selection","Line","normalizeAngle360","toRadians","Text","BBox","Matrix","BandScale","ticksToTree","treeLayout","AxisLabel","ChartAxis","GroupedCategoryAxisLabel","_super","_this","apply","arguments","grid","GroupedCategoryAxis","call","tickScale","longestSeparatorLength","translation","x","y","rotation","line","width","color","label","labelColor","_a","group","scale","paddingOuter","paddingInner","requestedRange","range","slice","gridLineSelection","select","selectAll","axisLineSelection","separatorSelection","labelSelection","defineProperty","get","domain","set","values","tickTree","tickTreeLayout","push","resizeTickTree","enumerable","configurable","value","updateRange","rr","vr","visibleRange","span","shift","start","s","length","convert","layout","lineHeight","resize","Math","abs","depth","min","bandwidth","fontSize","_gridLength","remove","setData","update","rangeStart","rangeEnd","rangeLength","parallelLabels","parallel","isHorizontal","cos","labelRotation","translationX","translationY","title","node","visible","labels","ticks","treeLabels","nodes","isLabelTree","sideFlag","mirrored","parallelFlipRotation","parallelFlipFlag","PI","regularFlipRotation","regularFlipFlag","updateGridLines","gridLength","exit","enterGridLines","enter","append","merge","updateLabels","enterLabels","labelFormatter","formatter","maxLeafLabelWidth","each","datum","index","fontStyle","fontWeight","fontFamily","fill","textBaseline","textAlign","screenY","screenX","enabled","text","String","bbox","computeBBox","labelX","padding","autoRotation","labelGrid","separatorData","rotationCenterX","children","parent","leafCount","number","x1","x2","toString","minX","forEach","max","updateSeparators","enterSeparators","epsilon","i","y1","y2","stroke","tick","undefined","strokeWidth","lineCount","lines","updateAxisLines","enterAxisLines","_","styles_1","gridStyle","styleCount_1","round","style","lineDash","options","includeTitle","excludeTitle","left","Infinity","right","top","bottom","computeTransformMatrix","matrix","flyweight","labelBBox","transformBBox","height","className","type"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Selection } from \"../../scene/selection\";\nimport { Line } from \"../../scene/shape/line\";\nimport { normalizeAngle360, toRadians } from \"../../util/angle\";\nimport { Text } from \"../../scene/shape/text\";\nimport { BBox } from \"../../scene/bbox\";\nimport { Matrix } from \"../../scene/matrix\";\n// import { Rect } from \"../../scene/shape/rect\"; debug (bbox)\nimport { BandScale } from \"../../scale/bandScale\";\nimport { ticksToTree, treeLayout } from \"../../layout/tree\";\nimport { AxisLabel } from \"../../axis\";\nimport { ChartAxis } from \"../chartAxis\";\nvar GroupedCategoryAxisLabel = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxisLabel, _super);\n    function GroupedCategoryAxisLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.grid = false;\n        return _this;\n    }\n    return GroupedCategoryAxisLabel;\n}(AxisLabel));\nvar GroupedCategoryAxis = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxis, _super);\n    function GroupedCategoryAxis() {\n        var _this = _super.call(this) || this;\n        // Label scale (labels are positionsed between ticks, tick count = label count + 1).\n        // We don't call is `labelScale` for consistency with other axes.\n        _this.tickScale = new BandScale();\n        _this.longestSeparatorLength = 0;\n        _this.translation = {\n            x: 0,\n            y: 0\n        };\n        /**\n         * Axis rotation angle in degrees.\n         */\n        _this.rotation = 0;\n        _this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        // readonly tick = new AxisTick();\n        _this.label = new GroupedCategoryAxisLabel();\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        _this.labelColor = 'rgba(87, 87, 87, 1)';\n        var _a = _this, group = _a.group, tickScale = _a.tickScale;\n        var scale = new BandScale();\n        scale.paddingOuter = 0.1;\n        scale.paddingInner = scale.paddingOuter * 2;\n        _this.requestedRange = scale.range.slice();\n        _this.scale = scale;\n        tickScale.paddingInner = 1;\n        tickScale.paddingOuter = 0;\n        _this.gridLineSelection = Selection.select(group).selectAll();\n        _this.axisLineSelection = Selection.select(group).selectAll();\n        _this.separatorSelection = Selection.select(group).selectAll();\n        _this.labelSelection = Selection.select(group).selectAll();\n        return _this;\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain;\n        },\n        set: function (values) {\n            this.scale.domain = values;\n            var tickTree = ticksToTree(values);\n            this.tickTreeLayout = treeLayout(tickTree);\n            var domain = values.slice();\n            domain.push('');\n            this.tickScale.domain = domain;\n            this.resizeTickTree();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GroupedCategoryAxis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        this.tickScale.range = scale.range = [start, start + span];\n        this.resizeTickTree();\n    };\n    GroupedCategoryAxis.prototype.resizeTickTree = function () {\n        var s = this.scale;\n        var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n        var layout = this.tickTreeLayout;\n        var lineHeight = this.lineHeight;\n        if (layout) {\n            layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, (range[1] - range[0]) < 0);\n        }\n    };\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n        get: function () {\n            return this.label.fontSize * 1.5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         */\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n                this.labelSelection = this.labelSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    GroupedCategoryAxis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, label = _a.label, tickScale = _a.tickScale, requestedRange = _a.requestedRange;\n        var rangeStart = scale.range[0];\n        var rangeEnd = scale.range[1];\n        var rangeLength = Math.abs(rangeEnd - rangeStart);\n        var bandwidth = (rangeLength / scale.domain.length) || 0;\n        var parallelLabels = label.parallel;\n        var rotation = toRadians(this.rotation);\n        var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n        var labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var title = this.title;\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n        // The phantom root of the tree layout is used instead.\n        if (title) {\n            title.node.visible = false;\n        }\n        var lineHeight = this.lineHeight;\n        // Render ticks and labels.\n        var tickTreeLayout = this.tickTreeLayout;\n        var labels = scale.ticks();\n        var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n        var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n        var ticks = tickScale.ticks();\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, π] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = (!labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI) ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = (!labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI) ? -1 : 1;\n        var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n        updateGridLines.exit.remove();\n        var enterGridLines = updateGridLines.enter.append(Line);\n        var gridLineSelection = updateGridLines.merge(enterGridLines);\n        var updateLabels = this.labelSelection.setData(treeLabels);\n        updateLabels.exit.remove();\n        var enterLabels = updateLabels.enter.append(Text);\n        var labelSelection = updateLabels.merge(enterLabels);\n        var labelFormatter = label.formatter;\n        var maxLeafLabelWidth = 0;\n        labelSelection\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n            // label.textBaseline = parallelLabels && !labelRotation\n            //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n            //     : 'middle';\n            node.textAlign = 'center';\n            node.translationX = datum.screenY - label.fontSize * 0.25;\n            node.translationY = datum.screenX;\n            if (index === 0) { // use the phantom root as the axis title\n                if (title && title.enabled && labels.length > 0) {\n                    node.visible = true;\n                    node.text = title.text;\n                    node.fontSize = title.fontSize;\n                    node.fontStyle = title.fontStyle;\n                    node.fontWeight = title.fontWeight;\n                    node.fontFamily = title.fontFamily;\n                    node.textBaseline = 'hanging';\n                }\n                else {\n                    node.visible = false;\n                }\n            }\n            else {\n                node.text = labelFormatter\n                    ? labelFormatter({\n                        value: String(datum.label),\n                        index: index\n                    })\n                    : String(datum.label);\n                node.visible =\n                    datum.screenX >= requestedRange[0] &&\n                        datum.screenX <= requestedRange[1];\n            }\n            var bbox = node.computeBBox();\n            if (bbox && bbox.width > maxLeafLabelWidth) {\n                maxLeafLabelWidth = bbox.width;\n            }\n        });\n        var labelX = sideFlag * label.padding;\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        var labelGrid = this.label.grid;\n        var separatorData = [];\n        labelSelection.each(function (label, datum, index) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            if (!datum.children.length) {\n                label.rotation = labelRotation;\n                label.textAlign = 'end';\n                label.textBaseline = 'middle';\n            }\n            else {\n                label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n                if (isHorizontal) {\n                    label.rotation = autoRotation;\n                }\n                else {\n                    label.rotation = -Math.PI / 2;\n                }\n            }\n            // Calculate positions of label separators for all nodes except the root.\n            // Each separator is placed to the top of the current label.\n            if (datum.parent && isLabelTree) {\n                var y = !datum.children.length\n                    ? datum.screenX - bandwidth / 2\n                    : datum.screenX - datum.leafCount * bandwidth / 2;\n                if (!datum.children.length) {\n                    if ((datum.number !== datum.children.length - 1) || labelGrid) {\n                        separatorData.push({\n                            y: y,\n                            x1: 0,\n                            x2: -maxLeafLabelWidth - _this.label.padding * 2,\n                            toString: function () { return String(index); }\n                        });\n                    }\n                }\n                else {\n                    var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n                    separatorData.push({\n                        y: y,\n                        x1: x + lineHeight,\n                        x2: x,\n                        toString: function () { return String(index); }\n                    });\n                }\n            }\n        });\n        // Calculate the position of the long separator on the far bottom of the axis.\n        var minX = 0;\n        separatorData.forEach(function (d) { return minX = Math.min(minX, d.x2); });\n        this.longestSeparatorLength = Math.abs(minX);\n        separatorData.push({\n            y: Math.max(rangeStart, rangeEnd),\n            x1: 0,\n            x2: minX,\n            toString: function () { return String(separatorData.length); }\n        });\n        var updateSeparators = this.separatorSelection.setData(separatorData);\n        updateSeparators.exit.remove();\n        var enterSeparators = updateSeparators.enter.append(Line);\n        var separatorSelection = updateSeparators.merge(enterSeparators);\n        this.separatorSelection = separatorSelection;\n        var epsilon = 0.0000001;\n        separatorSelection.each(function (line, datum, i) {\n            line.x1 = datum.x1;\n            line.x2 = datum.x2;\n            line.y1 = datum.y;\n            line.y2 = datum.y;\n            line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n            line.stroke = _this.tick.color;\n            line.fill = undefined;\n            line.strokeWidth = 1;\n        });\n        this.gridLineSelection = gridLineSelection;\n        this.labelSelection = labelSelection;\n        // Render axis lines.\n        var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n        var lines = [];\n        for (var i = 0; i < lineCount; i++) {\n            lines.push(i);\n        }\n        var updateAxisLines = this.axisLineSelection.setData(lines);\n        updateAxisLines.exit.remove();\n        var enterAxisLines = updateAxisLines.enter.append(Line);\n        var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n        this.axisLineSelection = axisLineSelection;\n        axisLineSelection.each(function (line, _, index) {\n            var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n            line.x1 = x;\n            line.x2 = x;\n            line.y1 = requestedRange[0];\n            line.y2 = requestedRange[1];\n            line.strokeWidth = _this.line.width;\n            line.stroke = _this.line.color;\n            line.visible = labels.length > 0 && (index === 0 || (labelGrid && isLabelTree));\n        });\n        if (this.gridLength) {\n            var styles_1 = this.gridStyle;\n            var styleCount_1 = styles_1.length;\n            gridLineSelection\n                .each(function (line, datum, index) {\n                var y = Math.round(tickScale.convert(datum));\n                line.x1 = 0;\n                line.x2 = -sideFlag * _this.gridLength;\n                line.y1 = y;\n                line.y2 = y;\n                line.visible = y >= requestedRange[0] && y <= requestedRange[1] &&\n                    Math.abs(line.parent.translationY - rangeStart) > 1;\n                var style = styles_1[index % styleCount_1];\n                line.stroke = style.stroke;\n                line.strokeWidth = _this.tick.width;\n                line.lineDash = style.lineDash;\n                line.fill = undefined;\n            });\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    GroupedCategoryAxis.prototype.computeBBox = function (options) {\n        var includeTitle = !options || !options.excludeTitle;\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        this.labelSelection.each(function (label, _, index) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            if (index > 0 || includeTitle) { // first node is the root (title)\n                label.computeTransformMatrix();\n                var matrix = Matrix.flyweight(label.matrix);\n                var labelBBox = label.computeBBox();\n                if (labelBBox) {\n                    var bbox = matrix.transformBBox(labelBBox);\n                    left = Math.min(left, bbox.x);\n                    right = Math.max(right, bbox.x + bbox.width);\n                    top = Math.min(top, bbox.y);\n                    bottom = Math.max(bottom, bbox.y + bbox.height);\n                }\n            }\n        });\n        return new BBox(left, top, Math.max(right - left, this.longestSeparatorLength), bottom - top);\n    };\n    // debug (bbox)\n    // private bboxRect = (() => {\n    //     const rect = new Rect();\n    //     rect.fill = undefined;\n    //     rect.stroke = 'red';\n    //     rect.strokeWidth = 1;\n    //     rect.strokeOpacity = 0.2;\n    //     return rect;\n    // })();\n    GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n    GroupedCategoryAxis.type = 'groupedCategory';\n    return GroupedCategoryAxis;\n}(ChartAxis));\nexport { GroupedCategoryAxis };\n"]},"metadata":{},"sourceType":"module"}